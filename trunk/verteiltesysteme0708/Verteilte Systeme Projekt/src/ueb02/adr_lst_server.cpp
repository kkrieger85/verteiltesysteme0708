/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "adr_lst.h"
#include <cstring>
#include <unistd.h>
#include <iostream>
#include <map>

using namespace std;

/* Liste von Benutzername-Passwort-Daten-Tupel vorhandener Loginkennungen. */
static const char* logins[][3] = {
   { "foo", "bar", "Ein guter Freund des Hauses." },
   { "peter", "morphose", "Ein alter Bekannter." },
   { "butter", "brot", "Schmeckt gut." },
   { NULL, NULL, NULL }
};

/* Menge von Handles für gerade im System eingeloggte Benutzer. */
static map<int, int> handles;

int *
adr_lst_auth_1_svc(adr_lst_auth_data *argp, struct svc_req *rqstp)
{
	static int result;
   result = -1; // Muss eigenes Statement sein um bei JEDEM Aufruf neu zu initialisieren.

	sleep(1);
   
   int idx;
   for (int i = 0; result == -1; i++) {
      const char** login = logins[i];
      const char* user = login[0];
      const char* pass = login[1];
      
      if (!user || !pass)
         break;
      
      // Login OK?
      if (!strcmp(user, argp->username) && !strcmp(pass, argp->passwd)) {
         result = 0;
         idx = i;
      }
   }
   
   // Login OK?
   if (result != -1) {
      int handle;
      
      do {
         handle = rand();
      } while (handles.count(handle) > 0);
      
      // Handle zuweisen
      handles[handle] = idx;
      result = handle;
   }

	return &result;
}

adr_lst_query_result *
adr_lst_query_1_svc(int *argp, struct svc_req *rqstp)
{
	static adr_lst_query_result result;
   result.error = 0;
   
   std::map<int, int>::const_iterator pos = handles.find(*argp);
   
   if (pos == handles.end()) {
      result.error = -1;
   } else {
      strncpy(result.result, logins[pos->second][2], sizeof(result.result) - 1);
   }

	return &result;
}

int *
adr_lst_logoff_1_svc(int *argp, struct svc_req *rqstp)
{
   int handle = *argp;
	static int result = 0;
   
   if (handles.count(handle) == 0) {
      result = -1;
   } else {
      handles.erase(handle);
   }

	return &result;
}
